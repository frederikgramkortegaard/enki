{\rtf1\ansi\ansicpg1252\cocoartf2820
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # Enki Extensible Backend System\
\
## Overview\
\
This document describes how to implement an extensible backend system for Enki that supports both interpretation and compilation to multiple backends (CPU, CUDA, LLVM, etc.).\
\
## 1. Runtime System (Interpreter)\
\
### Directory Structure\
```\
greyscale_module/\
\uc0\u9500 \u9472 \u9472  greyscale.enki          # Enki library with dispatch logic\
\uc0\u9500 \u9472 \u9472  greyscale.cpp           # Pure C++ implementation\
\uc0\u9500 \u9472 \u9472  greyscale.cu            # CUDA kernel + C++ wrapper\
\uc0\u9500 \u9472 \u9472  CMakeLists.txt          # Build configuration\
\uc0\u9492 \u9472 \u9472  lib/                    # Output libraries\
    \uc0\u9500 \u9472 \u9472  libgreyscale_cpp.so\
    \uc0\u9492 \u9472 \u9472  libgreyscale_cuda.so\
```\
\
### Enki Library File (`greyscale.enki`)\
```rust\
// greyscale.enki\
extern greyscale_cuda(image) from "greyscale_cuda";\
extern greyscale_cpu(image) from "greyscale_cpp";\
\
func greyscale(image: MyImageType) -> MyImageType \{\
    if _meta.cuda_enabled && image.width * image.height > 256*256 \{\
        return greyscale_cuda(image);\
    \} else \{\
        return greyscale_cpu(image);\
    \}\
\}\
```\
\
### C++ Implementation (`greyscale.cpp`)\
```cpp\
#include "enki/eval.hpp"\
#include <vector>\
#include <cstdint>\
\
// Pure C++ implementation of greyscale\
extern "C" Value greyscale_cpu(const std::vector<Value>& args) \{\
    if (args.size() != 1) \{\
        throw std::runtime_error("greyscale_cpu(image): expects image");\
    \}\
    \
    auto img_val = std::dynamic_pointer_cast<ImageValue>(args[0]);\
    if (!img_val) \{\
        throw std::runtime_error("greyscale_cpu(image): expects image");\
    \}\
    \
    auto out = std::make_shared<ImageValue>(*img_val);\
    \
    // Pure C++ greyscale implementation\
    for (size_t i = 0; i + 2 < out->data.size(); i += 3) \{\
        uint8_t r = out->data[i], g = out->data[i + 1], b = out->data[i + 2];\
        uint8_t gray = static_cast<uint8_t>(0.299 * r + 0.587 * g + 0.114 * b);\
        out->data[i] = out->data[i + 1] = out->data[i + 2] = gray;\
    \}\
    \
    return out;\
\}\
```\
\
### CUDA Implementation (`greyscale.cu`)\
```cuda\
#include <cuda_runtime.h>\
#include "enki/eval.hpp"\
\
// CUDA kernel - pure GPU computation\
__global__ void greyscale_kernel(unsigned char* input, unsigned char* output, int width, int height) \{\
    int idx = blockIdx.x * blockDim.x + threadIdx.x;\
    int pixel_idx = idx * 3;\
    \
    if (idx < width * height) \{\
        unsigned char r = input[pixel_idx];\
        unsigned char g = input[pixel_idx + 1];\
        unsigned char b = input[pixel_idx + 2];\
        \
        unsigned char gray = static_cast<unsigned char>(0.299f * r + 0.587f * g + 0.114f * b);\
        \
        output[pixel_idx] = gray;\
        output[pixel_idx + 1] = gray;\
        output[pixel_idx + 2] = gray;\
    \}\
\}\
\
// C++ wrapper that handles CUDA setup and calls the kernel\
extern "C" Value greyscale_cuda(const std::vector<Value>& args) \{\
    if (args.size() != 1) \{\
        throw std::runtime_error("greyscale_cuda(image): expects image");\
    \}\
    \
    auto img_val = std::dynamic_pointer_cast<ImageValue>(args[0]);\
    if (!img_val) \{\
        throw std::runtime_error("greyscale_cuda(image): expects image");\
    \}\
    \
    int width = img_val->width;\
    int height = img_val->height;\
    int data_size = width * height * 3;\
    \
    // CUDA memory management and kernel launch\
    unsigned char *d_input, *d_output;\
    cudaMalloc(&d_input, data_size);\
    cudaMalloc(&d_output, data_size);\
    \
    cudaMemcpy(d_input, img_val->data.data(), data_size, cudaMemcpyHostToDevice);\
    \
    int block_size = 256;\
    int grid_size = (width * height + block_size - 1) / block_size;\
    greyscale_kernel<<<grid_size, block_size>>>(d_input, d_output, width, height);\
    cudaDeviceSynchronize();\
    \
    std::vector<uint8_t> output_data(data_size);\
    cudaMemcpy(output_data.data(), d_output, data_size, cudaMemcpyDeviceToHost);\
    \
    cudaFree(d_input);\
    cudaFree(d_output);\
    \
    return std::make_shared<ImageValue>(width, height, std::move(output_data), img_val->format);\
\}\
```\
\
### Build System (`CMakeLists.txt`)\
```cmake\
cmake_minimum_required(VERSION 3.18)\
project(greyscale_module)\
\
fi}